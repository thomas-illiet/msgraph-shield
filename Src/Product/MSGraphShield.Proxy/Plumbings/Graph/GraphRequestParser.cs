using MSGraphShield.Proxy.Exceptions;
using MSGraphShield.Proxy.Models;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Microsoft.OData.Edm;
using Microsoft.OData.Edm.Csdl;
using Microsoft.OData.UriParser;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Threading.Tasks;
using System.Xml;
using Titanium.Web.Proxy.Http;

namespace MSGraphShield.Proxy.Plumbings.Graph
{
    internal class GraphRequestParser
    {
        private readonly MetadataLoader _metadataLoader;
        private readonly ProxyConfiguration _proxyConfiguration;
        private readonly ILogger<GraphRequestParser> _logger;
        private readonly Dictionary<int, IEdmModel> _models = new Dictionary<int, IEdmModel>();

        /// <summary>
        /// Initializes a new instance of the <see cref="GraphRequestParser"/> class.
        /// </summary>
        /// <param name="configuration">The configuration.</param>
        /// <param name="logger">The logger.</param>
        public GraphRequestParser(IConfiguration configuration, ILogger<GraphRequestParser> logger)
        {
            _metadataLoader = configuration.GetSection(nameof(MetadataLoader)).Get<MetadataLoader>()
                ?? throw new InvalidOperationException("Metadata loader configuration is missing.");
            _proxyConfiguration = configuration.GetSection(nameof(ProxyConfiguration)).Get<ProxyConfiguration>()
                ?? throw new InvalidOperationException("Proxy configuration is missing.");
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public async Task InitializeAsync()
        {
            // Check if the metadata loader and endpoints list are null or empty
            if (_metadataLoader.Endpoints == null || !_metadataLoader.Endpoints.Any())
            {
                throw new InvalidOperationException("The metadata loader or endpoints list is null or empty");
            }

            foreach (var endpoint in _metadataLoader.Endpoints)
            {
                if (!endpoint.EndsWith("/"))
                {
                    throw new InvalidOperationException("The endpoint does not end with '/'");
                }

                _logger.LogInformation("Initialize metadata cache: {endpoint}", endpoint + "$metadata");
                var model = await GetOnlineModelAsync(endpoint);
                _models.Add(endpoint.GetHashCode(), model);
            }
        }

        /// <summary>
        /// Returns an IEdmModel for the given endpoint.
        /// </summary>
        /// <param name="endpoint">The endpoint.</param>
        /// <returns>The model generated by parsing.</returns>
        private async Task<IEdmModel> GetOnlineModelAsync(string endpoint)
        {
            var httpHandler = new HttpClientHandler();
            if (_proxyConfiguration.ExternalProxy != null)
            {
                var proxy = new WebProxy(
                   Host: _proxyConfiguration.ExternalProxy.HostName,
                   Port: _proxyConfiguration.ExternalProxy.Port)
                {
                    BypassProxyOnLocal = true,
                    UseDefaultCredentials = _proxyConfiguration.ExternalProxy.UseDefaultCredentials,
                };
                httpHandler = new HttpClientHandler { Proxy = proxy };
            }

            try
            {
                using var client = new HttpClient(handler: httpHandler, disposeHandler: true);
                using var response = await client.GetAsync(endpoint + "$metadata");
                if (!response.IsSuccessStatusCode)
                {
                    throw new HttpRequestException($"Request failed with status code {(int)response.StatusCode}: {response.ReasonPhrase}");
                }

                await using var stream = await response.Content.ReadAsStreamAsync();
                using var reader = XmlReader.Create(stream);
                return CsdlReader.Parse(reader);
            }
            catch (HttpRequestException ex)
            {
                throw new InternalServerException(ex, $"Failed to make a request to the metadata endpoint: {endpoint}");
            }
            catch (XmlException ex)
            {
                throw new InternalServerException(ex, $"Failed to parse the metadata XML for the metadata endpoint: {endpoint}");
            }
            catch (Exception ex)
            {
                throw new InternalServerException(ex, $"An error occurred while processing the metadata endpoint: {endpoint}");
            }
        }

        /// <summary>
        /// Initialize a UriParser.
        /// We have to initialize UriParser separately for parsing path,
        /// because we may set BatchReferenceCallback before ParsePath.
        /// </summary>
        public ODataUriParser Parse(Request request)
        {
            if (_models.Count == 0)
            {
                throw new InternalServerException("No models available to parse the request");
            }

            var serviceRoot = new Uri($"https://{request.RequestUri.Host}/{request.RequestUri.Segments[1]}");

            if (!_models.TryGetValue(serviceRoot.GetHashCode(), out var model))
            {
                throw new BadRequestException("No model was found for the request");
            }

            return new ODataUriParser(model, serviceRoot, request.RequestUri);
        }
    }
}
